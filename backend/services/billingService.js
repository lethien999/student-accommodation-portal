/**
 * Billing Service
 * 
 * Service for automatic rent billing calculation and generation.
 * Handles monthly bill creation, utility calculations, and notifications.
 * 
 * Follows Single Responsibility Principle - only handles billing logic.
 * 
 * @module services/billingService
 */
const {
    RentBilling,
    Accommodation,
    RentalContract,
    Property,
    User
} = require('../models');
const { Op } = require('sequelize');

/**
 * Generate billing period string (YYYY-MM)
 */
const getBillingPeriod = (year, month) => {
    return `${year}-${String(month).padStart(2, '0')}`;
};

/**
 * Calculate due date based on billing day
 */
const calculateDueDate = (year, month, billingDay = 10) => {
    // Due date is in the next month
    let dueMonth = month;
    let dueYear = year;

    // Add grace period (due in current month, day billingDay)
    const dueDate = new Date(dueYear, dueMonth - 1, billingDay);
    return dueDate;
};

/**
 * Get previous billing for an accommodation
 */
const getPreviousBilling = async (accommodationId, currentPeriod) => {
    const [year, month] = currentPeriod.split('-').map(Number);
    let prevMonth = month - 1;
    let prevYear = year;

    if (prevMonth < 1) {
        prevMonth = 12;
        prevYear -= 1;
    }

    const previousPeriod = getBillingPeriod(prevYear, prevMonth);

    return await RentBilling.findOne({
        where: {
            accommodationId,
            billingPeriod: previousPeriod
        }
    });
};

/**
 * Create a billing record for an accommodation
 */
const createBilling = async (accommodationId, billingData, options = {}) => {
    const { isAutoGenerated = false } = options;

    // Get accommodation with property and active contract
    const accommodation = await Accommodation.findByPk(accommodationId, {
        include: [
            {
                model: Property,
                as: 'property'
            },
            {
                model: RentalContract,
                as: 'rentalContracts',
                where: { status: 'active' },
                required: true,
                include: [{
                    model: User,
                    as: 'tenant',
                    attributes: ['id', 'username', 'email', 'phoneNumber']
                }]
            }
        ]
    });

    if (!accommodation) {
        throw new Error('Accommodation not found or no active contract');
    }

    const activeContract = accommodation.rentalContracts[0];
    if (!activeContract) {
        throw new Error('No active rental contract found');
    }

    const property = accommodation.property;
    const {
        billingMonth,
        billingYear,
        electricityPreviousReading = 0,
        electricityCurrentReading = 0,
        waterPreviousReading = 0,
        waterCurrentReading = 0,
        otherFees = 0,
        otherFeesDescription = '',
        discount = 0,
        discountReason = '',
        notes = ''
    } = billingData;

    const billingPeriod = getBillingPeriod(billingYear, billingMonth);

    // Check if billing already exists
    const existingBilling = await RentBilling.findOne({
        where: { accommodationId, billingPeriod }
    });

    if (existingBilling) {
        throw new Error(`Billing for period ${billingPeriod} already exists`);
    }

    // Get pricing from property or defaults
    const electricityPrice = property?.electricityPrice || 3500;
    const waterPrice = property?.waterPrice || 15000;
    const internetFee = property?.internetPrice || 0;
    const garbageFee = property?.garbagePrice || 20000;
    const billingDay = property?.billingDay || 10;

    // Get previous billing for balance
    const previousBilling = await getPreviousBilling(accommodationId, billingPeriod);
    const previousBalance = previousBilling?.remainingBalance || 0;

    // Calculate due date
    const dueDate = calculateDueDate(billingYear, billingMonth, billingDay);

    // Create billing record
    const billing = await RentBilling.create({
        accommodationId,
        tenantId: activeContract.tenantId,
        landlordId: activeContract.landlordId,
        propertyId: property?.id || null,
        contractId: activeContract.id,
        billingMonth,
        billingYear,
        billingPeriod,
        dueDate,
        roomRent: accommodation.price,
        electricityPreviousReading,
        electricityCurrentReading,
        electricityPrice,
        waterPreviousReading,
        waterCurrentReading,
        waterPrice,
        internetFee,
        garbageFee,
        parkingFee: 0,
        otherFees,
        otherFeesDescription,
        discount,
        discountReason,
        previousBalance,
        notes,
        isAutoGenerated,
        status: 'draft'
    });

    // Calculate totals
    billing.calculateTotals();
    await billing.save();

    return billing;
};

/**
 * Update billing with meter readings and recalculate
 */
const updateBillingReadings = async (billingId, readings) => {
    const billing = await RentBilling.findByPk(billingId);

    if (!billing) {
        throw new Error('Billing not found');
    }

    if (billing.status === 'paid' || billing.status === 'cancelled') {
        throw new Error('Cannot update paid or cancelled billing');
    }

    const {
        electricityPreviousReading,
        electricityCurrentReading,
        waterPreviousReading,
        waterCurrentReading,
        otherFees,
        otherFeesDescription,
        discount,
        discountReason,
        notes
    } = readings;

    // Update readings
    if (electricityPreviousReading !== undefined) billing.electricityPreviousReading = electricityPreviousReading;
    if (electricityCurrentReading !== undefined) billing.electricityCurrentReading = electricityCurrentReading;
    if (waterPreviousReading !== undefined) billing.waterPreviousReading = waterPreviousReading;
    if (waterCurrentReading !== undefined) billing.waterCurrentReading = waterCurrentReading;
    if (otherFees !== undefined) billing.otherFees = otherFees;
    if (otherFeesDescription !== undefined) billing.otherFeesDescription = otherFeesDescription;
    if (discount !== undefined) billing.discount = discount;
    if (discountReason !== undefined) billing.discountReason = discountReason;
    if (notes !== undefined) billing.notes = notes;

    // Recalculate
    billing.calculateTotals();
    await billing.save();

    return billing;
};

/**
 * Publish billing (change status from draft to pending)
 */
const publishBilling = async (billingId) => {
    const billing = await RentBilling.findByPk(billingId);

    if (!billing) {
        throw new Error('Billing not found');
    }

    if (billing.status !== 'draft') {
        throw new Error('Only draft billings can be published');
    }

    billing.status = 'pending';
    await billing.save();

    return billing;
};

/**
 * Record payment for a billing
 */
const recordPayment = async (billingId, paymentAmount, paymentMethod = 'cash') => {
    const billing = await RentBilling.findByPk(billingId);

    if (!billing) {
        throw new Error('Billing not found');
    }

    if (billing.status === 'cancelled') {
        throw new Error('Cannot pay cancelled billing');
    }

    billing.paidAmount = parseFloat(billing.paidAmount) + parseFloat(paymentAmount);
    billing.remainingBalance = parseFloat(billing.grandTotal) - parseFloat(billing.paidAmount);

    if (billing.remainingBalance <= 0) {
        billing.status = 'paid';
        billing.paidAt = new Date();
        billing.remainingBalance = 0;
    } else {
        billing.status = 'partial';
    }

    await billing.save();

    return billing;
};

/**
 * Generate billings for all active contracts (for cron job)
 */
const generateMonthlyBillings = async (targetMonth = null, targetYear = null) => {
    const now = new Date();
    const month = targetMonth || now.getMonth() + 1; // 1-12
    const year = targetYear || now.getFullYear();
    const billingPeriod = getBillingPeriod(year, month);

    console.log(`[BillingService] Generating billings for period: ${billingPeriod}`);

    // Get all active rental contracts
    const activeContracts = await RentalContract.findAll({
        where: { status: 'active' },
        include: [
            {
                model: Accommodation,
                as: 'accommodation',
                include: [{
                    model: Property,
                    as: 'property'
                }]
            },
            {
                model: User,
                as: 'tenant'
            }
        ]
    });

    console.log(`[BillingService] Found ${activeContracts.length} active contracts`);

    const results = {
        success: [],
        skipped: [],
        failed: []
    };

    for (const contract of activeContracts) {
        try {
            const accommodation = contract.accommodation;

            // Check if billing already exists
            const existing = await RentBilling.findOne({
                where: {
                    accommodationId: accommodation.id,
                    billingPeriod
                }
            });

            if (existing) {
                results.skipped.push({
                    accommodationId: accommodation.id,
                    reason: 'Already exists'
                });
                continue;
            }

            // Get previous billing for meter readings
            const prevBilling = await getPreviousBilling(accommodation.id, billingPeriod);

            // Create new billing with previous readings as starting point
            const billingData = {
                billingMonth: month,
                billingYear: year,
                electricityPreviousReading: prevBilling?.electricityCurrentReading || 0,
                electricityCurrentReading: prevBilling?.electricityCurrentReading || 0, // Will be updated manually
                waterPreviousReading: prevBilling?.waterCurrentReading || 0,
                waterCurrentReading: prevBilling?.waterCurrentReading || 0 // Will be updated manually
            };

            const billing = await createBilling(accommodation.id, billingData, { isAutoGenerated: true });

            results.success.push({
                billingId: billing.id,
                accommodationId: accommodation.id,
                period: billingPeriod
            });
        } catch (error) {
            results.failed.push({
                accommodationId: contract.accommodationId,
                error: error.message
            });
        }
    }

    console.log(`[BillingService] Results - Success: ${results.success.length}, Skipped: ${results.skipped.length}, Failed: ${results.failed.length}`);

    return results;
};

/**
 * Check and update overdue billings (for cron job)
 */
const updateOverdueBillings = async () => {
    const now = new Date();

    const overdueBillings = await RentBilling.update(
        { status: 'overdue' },
        {
            where: {
                status: 'pending',
                dueDate: { [Op.lt]: now }
            }
        }
    );

    console.log(`[BillingService] Marked ${overdueBillings[0]} billings as overdue`);

    return overdueBillings[0];
};

/**
 * Get billing statistics for landlord
 */
const getLandlordBillingStats = async (landlordId, period = null) => {
    const where = { landlordId };

    if (period) {
        where.billingPeriod = period;
    }

    const billings = await RentBilling.findAll({ where });

    const stats = {
        totalBillings: billings.length,
        totalAmount: 0,
        totalPaid: 0,
        totalPending: 0,
        totalOverdue: 0,
        byStatus: {
            draft: 0,
            pending: 0,
            partial: 0,
            paid: 0,
            overdue: 0,
            cancelled: 0
        }
    };

    billings.forEach(billing => {
        stats.totalAmount += parseFloat(billing.grandTotal || 0);
        stats.totalPaid += parseFloat(billing.paidAmount || 0);

        if (['pending', 'partial'].includes(billing.status)) {
            stats.totalPending += parseFloat(billing.remainingBalance || 0);
        }
        if (billing.status === 'overdue') {
            stats.totalOverdue += parseFloat(billing.remainingBalance || 0);
        }

        stats.byStatus[billing.status] = (stats.byStatus[billing.status] || 0) + 1;
    });

    return stats;
};

module.exports = {
    getBillingPeriod,
    calculateDueDate,
    getPreviousBilling,
    createBilling,
    updateBillingReadings,
    publishBilling,
    recordPayment,
    generateMonthlyBillings,
    updateOverdueBillings,
    getLandlordBillingStats
};
